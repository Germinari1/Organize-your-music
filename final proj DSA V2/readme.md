# Music Collection Manager

## Description
This program allows a user to manage a music collection of CD and vinyl artifacts. The user is able to view the collection, add and remove items from it, calculate its price, and more. The program utilizes custom implementations of various data structures such as linked lists (for implementing queues), AVL trees, maps, and vectors.

## Features
- Add, edit, and remove CDs and vinyl disks from the collection
- Display the entire collection or visualize individual items
- Export the collection to a file and load it from a file
- Create playlists (queues) of CDs and vinyl disks
- Display the created playlists
- Add and display music artifact suppliers (using an AVL tree)

## Usage
Upon running the program, you will be presented with a menu of available actions. Follow the on-screen instructions to perform various operations on your music collection.

## Data Structures
This program employs the following custom-implemented data structures:

- **Linked List**: Used for implementing queues for playlists.
- **Queue**: Used to store playlists.
- **AVL Tree**: Employed for storing and managing music artifact suppliers.
- **Map**: Used for storing and retrieving key-value pairs (e.g., genre-value mappings).
- **Vector**: Used to store and manage collections of musical artifacts.

## Building and Running
1. Ensure you have a C++ compiler installed on your system.
2. Compile the source code files (`main.cpp`, `musicArtifact.cpp`, `date.cpp`, `vinyl.cpp`, `CD.cpp`, `shelf.cpp`, `myMap_v2.cpp`, `myQueueLL.cpp`, `myVector.cpp`, `avlBT.cpp`, and any other necessary files).
3. Link the object files to create the executable.
4. Run the executable to start the program.

##  Additional notes
- The file `exported_collection.txt` was generated by exporting a collection of CDs and vinyls from a run of the program. It can also be used to quickly load items into a running program by using the feature `Load collection from file`.
- You will notice that this folder contains implementations of some data structures not really used in the final project. They are here due to initial ideas that could employ them, but ended up being discarted. However, I decided to keep those data structures implementations here becasue they, in some sense, reflect a design and creative process of building a software and could be interesting to the reader. A analogous situation happens with the file `utilities.txt`.